## Двойное суффиксное дерево.

B. Даны строки `s` и `t`. Постройте сжатое суффиксное дерево, которое содержит все суффиксы строки `s` и строки `t`. Найдите такое дерево, которое содержит минимальное количество вершин.

*Формат ввода.*

В первой строке записана строка s (1 ≤ |s| ≤ 105), последний символ строки равен `$`, остальные символы строки — маленькие латинские буквы.

Во второй строке записана строка t (1 ≤ |t| ≤ 105), последний символ строки равен `#`, остальные символы строки — маленькие латинские буквы.
 
*Формат вывода.*

Пронумеруйте вершины дерева от 0 до n-1 в порядке обхода в глубину, обходя поддеревья в порядке лексикографической сортировки исходящих из вершины ребер. Используйте ASCII-коды символов для опре- деления их порядка.

В первой строке выведите целое число n — количество вершин дерева. В следующих n-1 строках выведите описание вершин дерева, кроме корня, в порядке увеличения их номеров.

Описание вершины дерева v состоит из четырех целых чисел: p, w, lf, rg, где p (0 ≤ p < n, p ≠ v) — номер родителя текущей вершины, w (0 ≤ w ≤ 1) — номер строки для определения подстроки на ребре. Если w = 0, то на ребре, ведущем из p в v, написана подстрока s[lf … rg - 1] (0 ≤ lf < rg ≤ |s|). Если w = 1, то на ребре, ведущем из p в v, написана подстрока t[lf … rg - 1] (0 ≤ lf < rg ≤ |t|).

In:
```
ab$
ac#
```
Out:
```
8
0 1 2 3
0 0 2 3
0 0 0 1
3 0 1 3
3 1 1 3
0 0 1 3
0 1 1 3
```
In:
```
aba$
baab#
```
Out:
```
14
0 1 4 5
0 0 3 4
0 0 0 1
3 0 3 4
3 1 2 5
3 0 1 2
6 1 4 5
6 0 2 4
0 0 1 2
9 1 4 5
9 0 2 3
11 0 3 4
11 1 2 5
```
